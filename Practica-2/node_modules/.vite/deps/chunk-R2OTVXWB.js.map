{
  "version": 3,
  "sources": ["../../@vaadin/hilla-react-signals/src/polyfills.ts", "../../@vaadin/hilla-react-signals/node_modules/@preact/signals-react/runtime/src/index.ts", "../../nanoid/url-alphabet/index.js", "../../nanoid/index.browser.js", "../../@vaadin/hilla-react-signals/src/events.ts", "../../@vaadin/hilla-react-signals/src/FullStackSignal.ts", "../../@vaadin/hilla-react-signals/src/ValueSignal.ts", "../../@vaadin/hilla-react-signals/src/NumberSignal.ts", "../../@vaadin/hilla-react-signals/src/CollectionSignal.ts", "../../@vaadin/hilla-react-signals/src/ListSignal.ts"],
  "sourcesContent": ["// TODO: Remove this polyfill when we move to ECMA2024\ndeclare global {\n  interface PromiseConstructor {\n    withResolvers<T>(): {\n      resolve(value: T): void;\n      reject(reason?: unknown): void;\n      promise: Promise<T>;\n    };\n  }\n}\n\nif (!('withResolvers' in Promise)) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Promise, 'withResolvers', {\n    configurable: true,\n    value<T>() {\n      let resolve: (value: T) => void;\n      let reject: (reason?: unknown) => void;\n      const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n      });\n      return { resolve: resolve!, reject: reject!, promise };\n    },\n  });\n}\n\nexport {};\n", "import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n} from \"@preact/signals-core\";\nimport {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t});\n\t}, Empty);\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "import { nanoid } from 'nanoid';\n\nexport type StateEvent = Readonly<{\n  id: string;\n  type: string;\n  value: unknown;\n  accepted: boolean;\n  parentSignalId?: string;\n}>;\n\n/**\n * Creates a new state event type.\n */\ntype CreateStateEventType<V, T extends string, C extends Record<string, unknown> = Record<never, never>> = Readonly<{\n  type: T;\n  value: V;\n}> &\n  Readonly<C> &\n  StateEvent;\n\n/**\n * A state event received from the server describing the current state of the\n * signal.\n */\nexport type SnapshotStateEvent<T> = CreateStateEventType<T, 'snapshot'>;\n\n/**\n * A state event defines a new value of the signal shared with the server. The\n */\nexport type SetStateEvent<T> = CreateStateEventType<T, 'set'>;\n\nexport function createSetStateEvent<T>(value: T, signalId?: string, parentSignalId?: string): SetStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'set',\n    value,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type ReplaceStateEvent<T> = CreateStateEventType<T, 'replace', { expected: T }>;\n\nexport function createReplaceStateEvent<T>(\n  expected: T,\n  value: T,\n  signalId?: string,\n  parentSignalId?: string,\n): ReplaceStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'replace',\n    value,\n    expected,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type IncrementStateEvent = CreateStateEventType<number, 'increment'>;\n\nexport function createIncrementStateEvent(delta: number): IncrementStateEvent {\n  return {\n    id: nanoid(),\n    type: 'increment',\n    value: delta,\n    accepted: false,\n  };\n}\n\nexport type ListEntry<T> = Readonly<{\n  id: string;\n  prev?: string;\n  next?: string;\n  value: T;\n}>;\n\nexport type ListSnapshotStateEvent<T> = CreateStateEventType<never, 'snapshot', { entries: Array<ListEntry<T>> }>;\n\nexport type InsertLastStateEvent<T> = CreateStateEventType<T, 'insert', { position: 'last'; entryId?: string }>;\n\nexport function createInsertLastStateEvent<T>(value: T): InsertLastStateEvent<T> {\n  return {\n    id: nanoid(),\n    type: 'insert',\n    value,\n    position: 'last',\n    accepted: false,\n  };\n}\n\nexport type RemoveStateEvent = CreateStateEventType<never, 'remove', { entryId: string }>;\n\nexport function createRemoveStateEvent(entryId: string): RemoveStateEvent {\n  return {\n    id: nanoid(),\n    type: 'remove',\n    entryId,\n    value: undefined as never,\n    accepted: false,\n  };\n}\n\nfunction isStateEvent(event: unknown): event is StateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    typeof (event as { type?: unknown }).type === 'string' &&\n    typeof (event as { value?: unknown }).value !== 'undefined' &&\n    typeof (event as { accepted?: unknown }).accepted === 'boolean'\n  );\n}\n\nexport function isSnapshotStateEvent<T>(event: unknown): event is SnapshotStateEvent<T> {\n  return isStateEvent(event) && event.type === 'snapshot';\n}\n\nexport function isSetStateEvent<T>(event: unknown): event is SetStateEvent<T> {\n  return isStateEvent(event) && event.type === 'set';\n}\n\nexport function isReplaceStateEvent<T>(event: unknown): event is ReplaceStateEvent<T> {\n  return (\n    isStateEvent(event) && typeof (event as { expected?: unknown }).expected !== 'undefined' && event.type === 'replace'\n  );\n}\n\nexport function isIncrementStateEvent(event: unknown): event is IncrementStateEvent {\n  return isStateEvent(event) && event.type === 'increment';\n}\n\nexport function isListSnapshotStateEvent<T>(event: unknown): event is ListSnapshotStateEvent<T> {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'snapshot' &&\n    (event as { entries?: unknown }).entries instanceof Array &&\n    typeof (event as { accepted?: unknown }).accepted !== 'undefined'\n  );\n}\n\nexport function isInsertLastStateEvent<T>(event: unknown): event is InsertLastStateEvent<T> {\n  return isStateEvent(event) && event.type === 'insert' && (event as { position?: unknown }).position === 'last';\n}\n\nexport function isRemoveStateEvent(event: unknown): event is RemoveStateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'remove' &&\n    typeof (event as { entryId?: unknown }).entryId === 'string' &&\n    typeof (event as { value?: unknown }).value === 'undefined'\n  );\n}\n", "import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * A return type for signal operations that exposes a `result` property of type\n * `Promise`, that resolves when the operation is completed. It allows defining\n * callbacks to be run after the operation is completed, or error handling when\n * the operation fails.\n *\n * @example\n * ```ts\n * const sharedName = NameService.sharedName({ defaultValue: '' });\n * sharedName.replace('John').result\n *    .then(() => console.log('Name updated successfully'))\n *    .catch((error) => console.error('Failed to update the name:', error));\n * ```\n */\nexport interface Operation {\n  result: Promise<void>;\n}\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n\n  /**\n   * The unique identifier of the parent signal in the client.\n   */\n  parentClientSignalId?: string;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection {\n  readonly #id: string;\n  readonly config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params, parentClientSignalId } = this.config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n      parentClientSignalId,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent): Promise<void> {\n    const onTheFly = !this.#subscription;\n\n    if (onTheFly) {\n      this.connect();\n    }\n\n    await this.config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n\n    if (onTheFly) {\n      this.disconnect();\n    }\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\nexport const $setValueQuietly = Symbol('setValueQuietly');\nexport const $resolveOperation = Symbol('resolveOperation');\nexport const $createOperation = Symbol('createOperation');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id: string;\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig, id?: string) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.id = id ?? nanoid();\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        // For internal signals, the provided non-null to the constructor should\n        // be used along with the parent client side signal id when sending the\n        // set event to the server. For internal signals this combination is\n        // needed for addressing the correct parent/child signal instances on\n        // the server. For a standalone signal, both of them should be passed in\n        // as undefined:\n        const signalId = config.parentClientSignalId !== undefined ? this.id : undefined;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  // stores the promise handlers associated to operations\n  readonly #operationPromises = new Map<\n    string,\n    {\n      resolve(value: PromiseLike<void> | void): void;\n      reject(reason?: any): void;\n    }\n  >();\n\n  // creates the object to be returned by operations to allow defining callbacks\n  protected [$createOperation]({ id, promise }: { id?: string; promise?: Promise<void> }): Operation {\n    const thens = this.#operationPromises;\n    const promises: Array<Promise<void>> = [];\n\n    if (promise) {\n      // Add the provided promise to the list of promises\n      promises.push(promise);\n    }\n\n    if (id) {\n      // Create a promise to be associated to the provided id\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          thens.set(id, { resolve, reject });\n        }),\n      );\n    }\n\n    if (promises.length === 0) {\n      // If no promises were added, return a resolved promise\n      promises.push(Promise.resolve());\n    }\n\n    return {\n      result: Promise.allSettled(promises).then((results) => {\n        const lastResult = results[results.length - 1];\n        if (lastResult.status === 'fulfilled') {\n          return undefined;\n        }\n        throw lastResult.reason;\n      }),\n    };\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected [$setValueQuietly](value: T): void {\n    this.#paused = true;\n    super.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   * @returns The server response promise.\n   */\n  protected async [$update](event: StateEvent): Promise<void> {\n    return this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * Resolves the operation promise associated with the given event id.\n   *\n   * @param eventId - The event id.\n   * @param reason - The reason to reject the promise (if any).\n   */\n  protected [$resolveOperation](eventId: string, reason?: string): void {\n    const operationPromise = this.#operationPromises.get(eventId);\n    if (operationPromise) {\n      this.#operationPromises.delete(eventId);\n      if (reason) {\n        operationPromise.reject(reason);\n      } else {\n        operationPromise.resolve();\n      }\n    }\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n", "import { nanoid } from 'nanoid';\nimport {\n  createReplaceStateEvent,\n  createSetStateEvent,\n  isReplaceStateEvent,\n  isSetStateEvent,\n  isSnapshotStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  FullStackSignal,\n  type Operation,\n} from './FullStackSignal.js';\n\ntype PendingRequestsRecord<T> = Readonly<{\n  id: string;\n  callback(value: T): T;\n}> & { canceled: boolean };\n\n/**\n * An operation subscription that can be canceled.\n */\nexport interface OperationSubscription extends Operation {\n  cancel(): void;\n}\n\n/**\n * A full-stack signal that holds an arbitrary value.\n */\nexport class ValueSignal<T> extends FullStackSignal<T> {\n  readonly #pendingRequests = new Map<string, PendingRequestsRecord<T>>();\n\n  /**\n   * Sets the value.\n   * Note that the value change event that is propagated to the server as the\n   * result of this operation is not taking the last seen value into account and\n   * will overwrite the shared value on the server unconditionally (AKA: \"Last\n   * Write Wins\"). If you need to perform a conditional update, use the\n   * `replace` method instead.\n   *\n   * @param value - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  set(value: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createSetStateEvent(value, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    this[$setValueQuietly](value);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Replaces the value with a new one only if the current value is equal to the\n   * expected value.\n   *\n   * @param expected - The expected value.\n   * @param newValue - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  replace(expected: T, newValue: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Tries to update the value by applying the callback function to the current\n   * value. In case of a concurrent change, the callback is run again with an\n   * updated input value. This is repeated until the result can be applied\n   * without concurrent changes, or the operation is canceled.\n   *\n   * Note that there is no guarantee that cancel() will be effective always,\n   * since a succeeding operation might already be on its way to the server.\n   *\n   * @param callback - The function that is applied on the current value to\n   *                   produce the new value.\n   * @returns An operation object that allows to perform additional actions,\n   *                   including cancellation.\n   */\n  update(callback: (value: T) => T): OperationSubscription {\n    const newValue = callback(this.value);\n    const event = createReplaceStateEvent(this.value, newValue);\n    const promise = this[$update](event);\n    const pendingRequest = { id: nanoid(), callback, canceled: false };\n    this.#pendingRequests.set(event.id, pendingRequest);\n    return {\n      ...this[$createOperation]({ id: pendingRequest.id, promise }),\n      cancel: () => {\n        pendingRequest.canceled = true;\n      },\n    };\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    const record = this.#pendingRequests.get(event.id);\n    if (record) {\n      this.#pendingRequests.delete(event.id);\n\n      if (!(event.accepted || record.canceled)) {\n        this.update(record.callback);\n      }\n    }\n\n    let reason: string | undefined;\n    if (event.accepted || isSnapshotStateEvent<T>(event)) {\n      this.#applyAcceptedEvent(event);\n    } else {\n      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;\n    }\n    // `then` callbacks can be associated to the record or the event\n    // it depends on the operation that was performed\n    [record?.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id!, reason));\n  }\n\n  #applyAcceptedEvent(event: StateEvent): void {\n    if (isSetStateEvent<T>(event) || isSnapshotStateEvent<T>(event)) {\n      this.value = event.value;\n    } else if (isReplaceStateEvent<T>(event)) {\n      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {\n        this.value = event.value;\n      }\n    }\n  }\n}\n", "import { createIncrementStateEvent, isIncrementStateEvent, type StateEvent } from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\n/**\n * A signal that holds a number value. The underlying\n * value of this signal is stored and updated as a\n * shared value on the server.\n *\n * After obtaining the NumberSignal instance from\n * a server-side service that returns one, the value\n * can be updated using the `value` property,\n * and it can be read with or without the\n * `value` property (similar to a normal signal):\n *\n * @example\n * ```tsx\n * const counter = CounterService.counter();\n *\n * return (\n *    <Button onClick={() => counter.incrementBy(1)}>\n *      Click count: { counter }\n *    </Button>\n *    <Button onClick={() => counter.value = 0}>Reset</Button>\n * );\n * ```\n */\nexport class NumberSignal extends ValueSignal<number> {\n  readonly #sentIncrementEvents = new Map<string, StateEvent>();\n  /**\n   * Increments the value by the specified delta. The delta can be negative to\n   * decrease the value.\n   *\n   * This method differs from using the `++` or `+=` operators directly on the\n   * signal value. It performs an atomic operation to prevent conflicts from\n   * concurrent changes, ensuring that other users' modifications are not\n   * accidentally overwritten.\n   *\n   * @param delta - The delta to increment the value by. The delta can be\n   * negative.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  incrementBy(delta: number): Operation {\n    if (delta === 0) {\n      return { result: Promise.resolve() };\n    }\n    this[$setValueQuietly](this.value + delta);\n    const event = createIncrementStateEvent(delta);\n    this.#sentIncrementEvents.set(event.id, event);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (event.accepted && isIncrementStateEvent(event)) {\n      const sentEvent = this.#sentIncrementEvents.get(event.id);\n      if (sentEvent) {\n        this.#sentIncrementEvents.delete(event.id);\n      } else {\n        this[$setValueQuietly](this.value + event.value);\n      }\n      this[$resolveOperation](event.id);\n    } else {\n      super[$processServerResponse](event);\n    }\n  }\n}\n", "import { FullStackSignal } from './FullStackSignal.js';\n\n/**\n * A {@link FullStackSignal} that represents a collection of values.\n *\n * @typeParam T - The type of the values in the collection.\n */\nexport abstract class CollectionSignal<T> extends FullStackSignal<T> {\n  override get value(): T {\n    return super.value;\n  }\n\n  /**\n   * @readonly\n   */\n  override set value(_: never) {\n    throw new Error('Value of the collection signals cannot be set.');\n  }\n}\n", "import { CollectionSignal } from './CollectionSignal.js';\nimport {\n  createInsertLastStateEvent,\n  createRemoveStateEvent,\n  type InsertLastStateEvent,\n  isInsertLastStateEvent,\n  isListSnapshotStateEvent,\n  isRemoveStateEvent,\n  type ListSnapshotStateEvent,\n  type RemoveStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n  type ServerConnectionConfig,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\ntype EntryId = string;\ntype Entry<T> = {\n  id: EntryId;\n  value: ValueSignal<T>;\n  next?: EntryId;\n  prev?: EntryId;\n};\n\n/**\n * A {@link FullStackSignal} that represents a shared list of values, where each\n * value is represented by a {@link ValueSignal}.\n * The list can be modified by calling the defined methods to insert or remove\n * items, but the `value` property of a `ListSignal` instance is read-only and\n * cannot be assigned directly.\n * The value of each item in the list can be manipulated similar to a regular\n * {@link ValueSignal}.\n *\n * @typeParam T - The type of the values in the list.\n */\nexport class ListSignal<T> extends CollectionSignal<ReadonlyArray<ValueSignal<T>>> {\n  #head?: EntryId;\n  #tail?: EntryId;\n\n  readonly #values = new Map<string, Entry<T>>();\n\n  constructor(config: ServerConnectionConfig) {\n    const initialValue: Array<ValueSignal<T>> = [];\n    super(initialValue, config);\n  }\n\n  #computeItems(): ReadonlyArray<ValueSignal<T>> {\n    let current = this.#head;\n    const result: Array<ValueSignal<T>> = [];\n    while (current !== undefined) {\n      const entry = this.#values.get(current)!;\n      result.push(entry.value);\n      current = entry.next;\n    }\n    return result;\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (!event.accepted) {\n      this[$resolveOperation](\n        event.id,\n        `Server rejected the operation with id '${event.id}'. See the server log for more details.`,\n      );\n      return;\n    }\n    if (isListSnapshotStateEvent<T>(event)) {\n      this.#handleSnapshotEvent(event);\n    } else if (isInsertLastStateEvent<T>(event)) {\n      this.#handleInsertLastUpdate(event);\n    } else if (isRemoveStateEvent(event)) {\n      this.#handleRemoveUpdate(event);\n    }\n    this[$resolveOperation](event.id);\n  }\n\n  #handleInsertLastUpdate(event: InsertLastStateEvent<T>): void {\n    if (event.entryId === undefined) {\n      throw new Error('Unexpected state: Entry id should be defined when insert last event is accepted');\n    }\n    const valueSignal = new ValueSignal<T>(\n      event.value,\n      { ...this.server.config, parentClientSignalId: this.id },\n      event.entryId,\n    );\n    const newEntry: Entry<T> = { id: valueSignal.id, value: valueSignal };\n\n    if (this.#head === undefined) {\n      this.#head = newEntry.id;\n      this.#tail = this.#head;\n    } else {\n      const tailEntry = this.#values.get(this.#tail!)!;\n      tailEntry.next = newEntry.id;\n      newEntry.prev = this.#tail;\n      this.#tail = newEntry.id;\n    }\n    this.#values.set(valueSignal.id, newEntry);\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleRemoveUpdate(event: RemoveStateEvent): void {\n    const entryToRemove = this.#values.get(event.entryId);\n    if (entryToRemove === undefined) {\n      return;\n    }\n    this.#values.delete(event.id);\n    if (this.#head === entryToRemove.id) {\n      if (entryToRemove.next === undefined) {\n        this.#head = undefined;\n        this.#tail = undefined;\n      } else {\n        const newHead = this.#values.get(entryToRemove.next)!;\n        this.#head = newHead.id;\n        newHead.prev = undefined;\n      }\n    } else {\n      const prevEntry = this.#values.get(entryToRemove.prev!)!;\n      const nextEntry = entryToRemove.next !== undefined ? this.#values.get(entryToRemove.next) : undefined;\n      if (nextEntry === undefined) {\n        this.#tail = prevEntry.id;\n        prevEntry.next = undefined;\n      } else {\n        prevEntry.next = nextEntry.id;\n        nextEntry.prev = prevEntry.id;\n      }\n    }\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleSnapshotEvent(event: ListSnapshotStateEvent<T>): void {\n    event.entries.forEach((entry) => {\n      this.#values.set(entry.id, {\n        id: entry.id,\n        prev: entry.prev,\n        next: entry.next,\n        value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id),\n      });\n      if (entry.prev === undefined) {\n        this.#head = entry.id;\n      }\n      if (entry.next === undefined) {\n        this.#tail = entry.id;\n      }\n    });\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  /**\n   * Inserts a new value at the end of the list.\n   * @param value - The value to insert.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  insertLast(value: T): Operation {\n    const event = createInsertLastStateEvent(value);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Removes the given item from the list.\n   * @param item - The item to remove.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  remove(item: ValueSignal<T>): Operation {\n    const entryToRemove = this.#values.get(item.id);\n    if (entryToRemove === undefined) {\n      return { result: Promise.resolve() };\n    }\n    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);\n    const promise = this[$update](removeEvent);\n    return this[$createOperation]({ id: removeEvent.id, promise });\n  }\n}\n"],
  "mappings": "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",
  "names": ["major", "reactVersion", "split", "map", "Number", "Empty", "ReactElemType", "Symbol", "currentStore", "symDispose", "Symbol", "dispose", "startComponentEffect", "prevStore", "nextStore", "endEffect", "effect", "_start", "finishComponentEffect", "bind", "_ref2", "finalCleanup", "noop", "emptyEffectStore", "_usage", "_sources", "_callback", "_dispose", "subscribe", "getSnapshot", "f", "_queueMicroTask", "Promise", "prototype", "then", "resolve", "ensureFinalCleanup", "cleanupTrailingStore", "_currentStore", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "_useSignalsImplementation", "storeRef", "useRef", "current", "_ref", "effectInstance", "onChangeNotifyReact", "version", "unsubscribe", "this", "onStoreChange", "undefined", "prevUsage", "thisUsage", "end", "store", "useSyncExternalStore", "Object", "defineProperties", "Signal", "$$typeof", "configurable", "value", "ReactElemType", "type", "_ref3", "data", "props", "get", "ref", "useSignal", "value", "useMemo", "signal", "Empty", "useComputed", "compute", "$compute", "useRef", "current", "computed", "useSignalEffect", "cb", "callback", "useEffect", "effect", "v", "_"]
}
